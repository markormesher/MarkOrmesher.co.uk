extends ../../_shared/page-layout

block page-head
	link(rel = 'stylesheet', href = '/css/gallery.css')
	link(rel = 'stylesheet', href = '/vendor/fancybox/jquery.fancybox.css')

block page-body

	//- gallery images
	-
		galleryImages = [
			{href: '/images/projects/titanic/thumb-larger.jpg', title: 'Device list (spot the naming convention)'},
			{href: '/images/projects/titanic/dash.jpg', title: 'The dashboard, shortly after work started'},
			{href: '/images/projects/titanic/api.jpg', title: 'Titanic API'},
			{href: '/images/projects/titanic/command-line-mock.jpg', title: 'Mock-up of intended command line tool'}
		];
	script(type = 'text/javascript').
		window.galleryImages = !{JSON.stringify(galleryImages)};

	//- intro

	a.single-gallery-link(href = 'javascript:;', data-start = 0)
		img.bordered.inline-right(
		src = '/images/projects/titanic/thumb-larger.jpg'
		width = '400px'
		title = 'Titanic: a tool for synchronising host name aliases and Bash shortcuts')

	p.text-larger #[strong Why learn something new, when you could learn #[em everything] new?] #[em Titanic] is a hobby/learning-project for me: a simple web app and corresponding Linux command line tool designed to keep #[strong host name aliases] and #[strong Bash shortcuts] synchronised across all of my Linux devices and servers.

	p.text-larger The catch? #[strong I decided to build the tool from entirely new-to-me technologies], giving myself a #[a(href = '#deep-end') &quot;jump in at the deep end&quot;] learning opportunity.

	p: a.icon-link(href = 'https://github.com/markormesher/titanic', rel = 'external')
		i.fa.fa-github.text-highlight
		span #[em Titanic] on GitHub

	p: a.icon-link(href = '#summary', rel = 'external')
		i.fa.fa-angle-down.text-muted
		span Project Summary

	p: a.icon-link(href = '#deep-end')
		i.fa.fa-angle-down.text-muted
		span Jumping in at the Deep End

	p: a.icon-link(href = '#code-web')
		i.fa.fa-angle-down.text-muted
		span The Code: Web App

	p: a.icon-link(href = '#code-api')
		i.fa.fa-angle-down.text-muted
		span The Code: API

	p: a.icon-link(href = '#code-bash')
		i.fa.fa-angle-down.text-muted
		span The Code: Command Line Tool

	//- project summary

	h2#summary Project Summary

	p There are perhaps a dozen #[strong Linux-powered devices] that I interact with on a regular basis: my laptop, desktop and smartphone, a few RPis, a handful of servers, etc. They often need to talk to each other, so I use #[strong host name aliases] (#[em Chuck] character names, actually) instead of remembering a list of IP addresses. This means maintaining an #[code /etc/hosts] #[i.fa.fa-info-circle.text-very-muted(data-toggle = 'tooltip', title = 'For the non-Linux savvy: this file lets me map "nicknames" to IP addresses, similar to the way domain names work')] file on each machine, and updating all of them every time a new device enters the network -- such a hassle, right?

	p A similar problem can be found with #[strong Bash shortcuts]. I have a collection of shortcuts on my machines, ranging from aliases for common typos (#[code git puhs], anyone?) to one-command reductions of common tasks. Maintaining these across all devices would be impractical, and trying to use a shortcut that doesn't exist on #[em this] device yet is frustrating.

	p #[strong Enter the solution:] #[em Titanic]. An over-engineered solution to a low-key problem, aptly-named because #[strong it syncs everything].

	//- jumping in

	h2#deep-end Jumping in at the Deep End

	p I've always learned best by #[em doing]: I could watch videos or read books on a new language - and I sometimes do - but it will never beat getting my hands dirty and just #[strong playing with a new language], #[strong building things], and #[strong breaking things]. That's what I embraced with #[em Titanic]: I started it at a hackathon, with an objective to use #[strong solely new-to-me technologies].

	p All in all, the project has exposed me to #[strong eight new technologies] so far: Node.js, Express.js, MongoDB &amp; Mongoose, Jade, CoffeeScript, SCSS, #[del GitLab] (although I eventually switched to GitHub), and Bash scripting. I made only a few small concessions: I stuck with Git for version control, I used good ol' Bootstrap, I kept jQuery, and I didn't swap out my IDE.

	p The first few hours followed a #[strong very steep learning curve] (which I'm sure made for great entertainment for the teams nearby!), but after that things smoothed out and I started #[strong picking up new concepts] across the board at a rate I was very happy with.

	//- code: web

	h2#code-web The Code: Web App

	a.single-gallery-link(href = 'javascript:;', data-start = 1)
		img.bordered.inline-right(
		src = '/images/projects/titanic/dash.jpg'
		width = '400px'
		title = 'The dashboard, shortly after work started')

	p The web side of the project is straightforward: a relatively simple interface to #[strong view and manage the entities and relationships] controlled by the system. That includes devices, the host name aliases that connect them, Bash shortcuts, and their device assignments.

	p Really, the front end is nothing more than a few related models and their CRUD actions. The fun part was the #[em journey] that lead to its construction. I started with a blank Ubuntu VPS, then got down to installing #[strong Node.js], #[strong NPM], #[strong PM2], #[strong Nginx] etc. Once I had everything running smoothly I used another server to install #[strong GitLab] - a bit of set up later, I had a blank repository and I was ready to start building!

	p Having decided to use #[strong Express.js] as the powerhouse with #[strong Jade] and #[strong SCSS] to build the front-end, I set about knocking it together. I've never really been much of a designer, and it's not the family of skills this project was targeting, so I stuck to #[strong Bootstrap] and #[strong jQuery], both of which I've had a lot of experience with before.

	p Using #[strong MongoDB] and #[strong Mongoose], the models and data-access layer came together quite quickly, and from there it was just a matter of setting up the appropriate views and controllers to orchestrate everything. I continued to use #[strong CoffeeScript] for all front-end scripting, which I was already using to write my back-end #[strong Node.js] code.

	//- code: api

	h2#code-api The Code: API

	a.single-gallery-link(href = 'javascript:;', data-start = 2)
		img.bordered.inline-right(
		src = '/images/projects/titanic/api.jpg'
		width = '400px'
		title = 'Titanic API (the software shown here is Postman, which is awesome!)')

	p The API is exactly what you'd expect it to be: a bog-standard #[strong RESTful HTTP API] that exposes the entities and relationships managed by the web app. It does nothing particularly exciting - it exists solely as a data source for the command line tool.

	br.clearfix

	//- code: command line tool

	h2#code-bash The Code: Command Line Tool

	a.single-gallery-link(href = 'javascript:;', data-start = 3)
		img.bordered.inline-right(
		src = '/images/projects/titanic/command-line-mock.jpg'
		width = '400px'
		title = 'Mock-up of intended command line tool')

	p The command line tool is the last piece of the puzzle that needs to be built. It's a skeleton of a program right now, but it is in my pipeline for development over the next few months (unfortunately it takes a backseat to my #[em real] work). The tool, once finished, will be #[strong easy to use and blissfully simple]. Once set up, a simple command of #[code titanic sync] should update the machine with its specific set of host name aliases and Bash shortcuts.

	//- what next

	h2 What Next?

	p First, I need to finish the basic tool. But after that, I have a few ideas:

	ul
		li I'd like to see what else I can synchronise across my machines. The current feature set offers a lot of benefits to me, but I'm sure there's more I could unify. Settings perhaps? Users, even?

		li I'd also like to launch this as a publicly-accessible service. Right now it manages #[em my] devices and settings, but has no concept of different users managing #[em their] data. Adding this to the tool would take time, but it would mean that other people could use it to keep a family of Linux machines in check!

block scripts
	script(src = '/vendor/fancybox/jquery.fancybox.js')
	script(src = '/js/gallery.js')
