extends ../../_shared/page-layout

block page-head
	link(rel = 'stylesheet', href = '/projects/css/gallery.css')
	link(rel = 'stylesheet', href = '/_vendor/fancybox/jquery.fancybox.css')

block page-body

	//- gallery images
	-
		galleryImages = [
			{href: '/projects/images/titanic/thumb-larger.jpg', title: 'Device list (spot the naming convention)'},
			{href: '/projects/images/titanic/dash.jpg', title: 'The dashboard, shortly after work started'},
			{href: '/projects/images/titanic/api.jpg', title: 'Titanic API'},
			{href: '/projects/images/titanic/command-line-mock.jpg', title: 'Mock-up of intended command line tool'}
		];
	script(type = 'text/javascript').
		window.galleryImages = !{JSON.stringify(galleryImages)};

	//- intro

	a.single-gallery-link(href = 'javascript:;', data-start = 0)
		img.bordered.inline-right(
		src = '/projects/images/titanic/thumb-larger.jpg'
		width = '400px'
		title = 'Titanic: a tool for synchronising host name aliases and Bash shortcuts')

	p.intro During my #[a(href = '/positions#allianz-petplan') internship at Allianz Petplan] I suggested that three unused display screens could be put to better use with a live #[strong performance dashboard]. After producing design mocks, proposals and presentations, my idea was given the go-ahead and #[em Petplan Live!] was born.

	p.intro The project turned out to be more challenging than expected, forcing me to make use of some very #[strong hacky solutions] -- did you know you can #[strong store data in JavaScript comments?]

	p: a.icon-link(href = 'https://github.com/markormesher/petplan-live', rel = 'external')
		i.fa.fa-github.text-highlight
		span #[em Petplan Live!] on GitHub

	br.clearfix

	//- tech approach and challenges

	h2 Technical Approach &amp; Challenges

	h3 Plan A

	p My first plan was to use a #[strong Ruby] backend together with the #[strong Dashing.io] framework for the dashboard. Unfortunately this turned out to be a dead-end for me: getting a green-light for installing new software (i.e. Ruby) would be a rough and uncertain road, most likely taking me past the end of my internship.

	p
		i.fa.fa-fw.fa-angle-right.text-muted
		| #[strong No problem; surely I can think of another way...]

	h3 Plan B

	p Each of the three screens was to have a low-spec PC to drive it, so why not nominate one as a master to host the dashboard and the set up the others as slaves to read and display it? This #[strong master/slave arrangement] would require nothing more than simple #[strong JavaScript and AJAX], so there would be nothing extra to install. #[strong Sorted, right? Nope.] Getting approval to set up the network between the machines was going to take too long.

	p
		i.fa.fa-fw.fa-angle-right.text-muted
		| #[strong Okay, back to the drawing board...]

	h3 Plan C

	p After a few more non-starter ideas, I finally arrived at a solution: the entire application (including data) could be stored in a #[strong protected folder on the networked drive], the data itself could be stored in #[strong JavaScript-readable text files], and to get around the #[strong AJAX/local files issue] #[i.fa.fa-info-circle.text-very-muted(data-toggle = 'tooltip', title = 'Reading local files with AJAX is tricky, to say the least; a quick search on Stack Overflow will find many posts concerning this issue')] a combination of #[strong inline frames and cross-window messaging] could provide continually updating data without reloading the page.

	p
		i.fa.fa-fw.fa-angle-right.text-muted
		| #[strong That&#39;ll work, and it&#39;s so hacky it&#39;s beautiful.]

	//- jumping in

	h2#deep-end Jumping in at the Deep End

	p I've always learned best by #[em doing]: I could watch videos or read books on a new language - and I sometimes do - but it will never beat getting my hands dirty and just #[strong playing with a new language], #[strong building things], and #[strong breaking things]. That's what I embraced with #[em Titanic]: I started it at a hackathon, with an objective to use #[strong solely new-to-me technologies].

	p All in all, the project has exposed me to #[strong seven new technologies] so far: Node.js, Express.js, MongoDB &amp; Mongoose, Jade, CoffeeScript, SCSS, #[del GitLab] (although I eventually switched to GitHub), and I will soon be adding Bash scripting to the list. I made only a few small concessions: I stuck with Git for version control, I used good ol' Bootstrap, I kept jQuery, and I didn't swap out my IDE.

	p The first few hours followed a #[strong very steep learning curve] (which I'm sure made for great entertainment for the teams nearby!), but after that things smoothed out and I started #[strong picking up new concepts] across the board at a rate I was very happy with.

	//- code: web

	h2 The Code: Web App

	a.single-gallery-link(href = 'javascript:;', data-start = 1)
		img.bordered.inline-right(
		src = '/projects/images/titanic/dash.jpg'
		width = '400px'
		title = 'The dashboard, shortly after work started')

	p The web side of the project is straightforward: a relatively simple interface to #[strong view and manage the entities and relationships] controlled by the system. That includes devices, the host name aliases that connect them, Bash shortcuts, and their device assignments.

	p Really, the front end is nothing more than a few related models and their CRUD actions. The fun part was the #[em journey] that lead to its construction. I started with a blank Ubuntu VPS, then got down to installing #[strong Node.js], #[strong NPM], #[strong PM2], #[strong Nginx] etc. Once I had everything running smoothly I used another server to install #[strong GitLab] - a bit of set up later, I had a blank repository and I was ready to start building!

	p Having decided to use #[strong Express.js] as the powerhouse with #[strong Jade] and #[strong SCSS] to build the front-end, I set about knocking it together. I've never really been much of a designer, and it's not the family of skills this project was targeting, so I stuck to #[strong Bootstrap] and #[strong jQuery], both of which I've had a lot of experience with before.

	p Using #[strong MongoDB] and #[strong Mongoose], the models and data-access layer came together quite quickly, and from there it was just a matter of setting up the appropriate views and controllers or orchestrate everything. I continued to use #[strong CoffeeScript] for all front-end scripting, which I was already using to write my back-end #[strong Node.js] code.

	//- code: api

	h2 The Code: API

	a.single-gallery-link(href = 'javascript:;', data-start = 2)
		img.bordered.inline-right(
		src = '/projects/images/titanic/api.jpg'
		width = '400px'
		title = 'Titanic API (the software shown here is Postman, which is awesome!)')

	p The API is exactly what you'd expect it to be: a bog-standard #[strong RESTful HTTP API] that exposes the entities and relationships managed by the web app. It does nothing particularly exciting - it exists solely as a data source for the command line tool.

	br.clearfix

	//- code: command line tool

	h2 The Code: Command Line Tool

	a.single-gallery-link(href = 'javascript:;', data-start = 3)
		img.bordered.inline-right(
		src = '/projects/images/titanic/command-line-mock.jpg'
		width = '400px'
		title = 'Mock-up of intended command line tool')

	p The command line tool is the last piece of the puzzle that needs to be built. It's a skeleton of a program right now, but it is in my pipeline for development over the next few months (unfortunately it takes a backseat to my #[em real] work). The tool, once finished, will be #[strong easy to use and blissfully simple]. Once set up, a simple command of #[code titanic sync] should update the machine with its specific set of host name aliases and Bash shortcuts.

	//- what next

	h2 What Next?

	p First, I need to finish the basic tool. But after that, I have a few ideas:

	ul
		li I'd like to see what else I can synchronise across my machines. The current feature set offers a lot of benefits to me, but I'm sure there's more I could unify. Settings perhaps? Users, even?

		li I'd also like to launch this as a publicly-accessible service. Right now it manages #[em my] devices and settings, but has no concept of different users managing #[em their] data. Adding this to the tool would take time, but it would mean that other people could use it to keep a family of Linux machines in check!

block scripts
	script(src = '/_vendor/fancybox/jquery.fancybox.js')
	script(src = '/projects/js/gallery.js')
